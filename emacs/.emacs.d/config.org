#+PROPERTY: header-args    :results silent
* use-package
   :PROPERTIES:
   :created:  2020-01-29 11:36:05 CST
   :END:
I use =use-package=. This configuration needs to be at the top. 

When I open emacs on a new machine, my packages should be automatically
downloaded. This is the recommended method.
#+BEGIN_SRC emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+END_SRC

[2020-02-24 Mon] Trying to get set up on SLS computers again. There's a
problem---some packages don't support old emacs versions. I'm debating
whether it makes sense to always ensure.
* org
Related to =org-mode=. It's amazing how this has taken over my life. 

First, add the modules we use. 
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-modules 'org-habit)
#+END_SRC

Now, load it. There's no point to delay. 
#+BEGIN_SRC emacs-lisp
  (require 'org)
#+END_SRC

Define the prefix key and bind it. 
#+BEGIN_SRC emacs-lisp
  (fset 'jmw-org-prefix (make-sparse-keymap))
  (global-set-key (kbd "C-c o") 'jmw-org-prefix)
#+END_SRC
** sched
My scheduling subsystem. As of [2020-01-08 Wed], described in
=~/core/mind/sys/meta=. 
*** agenda
   :PROPERTIES:
   :created:  2020-01-08 20:17:40 CST
   :END:
Related to the agenda, for instance:
- what displays
- how it displays
- how it is invoked

The main key sequence is
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-ca" 'org-agenda)
#+END_SRC

Other:
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-window-setup 'other-window)
  (setq org-agenda-restore-windows-after-quit t)
  (setq org-agenda-files '("~/core/mind/sys/short/proc/main.org"))
  (setq org-habit-show-habits-only-for-today nil)
  (defun jmw-org-make-habit ()
    "Turn the following heading into a habit. Schedules it for
  today with .+1d/2d repeater interval."
    (interactive)
    (let ((time (concat
		 "<"
		 (format-time-string "%F") ;; yyyy-mm-dd
		 " .+1d/2d")))
      (org-set-property "STYLE" "habit")
      (org-schedule '(1) time)))
  (define-key 'jmw-org-prefix "h" 'jmw-org-make-habit)
#+END_SRC

Specifying which days appear in the agenda:
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-span 10)
  (setq org-agenda-start-day "-4d")
#+END_SRC
**** todo keyword
Set todo keywords.
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
	'((sequence "TODO(t)" "WAIT(w)" "|" "DONE(d)" "CANCEL(c)")))
#+END_SRC

Better colors:
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keyword-faces
	'(("CANCEL" . (:foreground "red" :weight bold))
	  ("WAIT" . (:foreground "yellow" :weight bold))))
#+END_SRC
*** org-clock
   :PROPERTIES:
   :created:  2020-01-08 20:31:18 CST
   :END:
The =org-clock= feature. 
#+BEGIN_SRC emacs-lisp
  (require 'org-clock) ;; The functions here are autoloaded, but I load it
		       ;; now to add 'org-clock-out-if-current
  (setq org-clock-history-length 35)
  (setq org-clock-mode-line-total 'today)
  (defun jmw-org-clock-out-up ()
    "Clock out and go up a process in the stack."
    (interactive)
    (when (org-clocking-p)
      (let ((org-log-note-clock-out nil)
	    (org-clock-out-switch-to-state nil))
	(org-clock-out)))
    (pop org-clock-history)
    (let* ((marker (pop org-clock-history))
	   (buf (marker-buffer marker)))
      (select-window (jmw-main-sched-window))
      (goto-char marker)
      (org-clock-in)))
  (define-key 'jmw-org-prefix "o" 'jmw-org-clock-out-up)

  ;; code copied from ~org-clock-out-if-current~
  (defun jmw-org-clock-out-if-current ()
    (when (and (org-clocking-p)
	       org-clock-out-when-done
	       (marker-buffer org-clock-marker)
	       (or (and (eq t org-clock-out-when-done)
			(member org-state org-done-keywords))
		   (and (listp org-clock-out-when-done)
			(member org-state org-clock-out-when-done)))
	       (equal (or (buffer-base-buffer (org-clocking-buffer))
			  (org-clocking-buffer))
		      (or (buffer-base-buffer (current-buffer))
			  (current-buffer)))
	       (< (point) org-clock-marker)
	       (> (save-excursion (outline-next-heading) (point))
		  org-clock-marker))
      (org-auto-repeat-maybe org-state)
      (jmw-org-clock-out-up)))
  (add-hook 'org-after-todo-state-change-hook
	    'jmw-org-clock-out-if-current)
  (remove-hook 'org-after-todo-state-change-hook
	       'org-clock-out-if-current)
  (add-hook 'org-clock-goto-hook
	    (lambda ()
	      (recenter-top-bottom 18)))
#+END_SRC

A formalization of pushing a task onto the stack. Semantically, pushing
a task is saying: the following is required, or at least relevant, to
completing the current task. This can be viewed as a special, important
case of inserting a TODO item. 

As of [2020-01-10 Fri], there is no symmetric notion for queueing a
task. Queueing a task can be done using ordinary insertion of a TODO
item. There is no notion of deferring a task (as in Go's =defer=
keyword) because it can be done using ordinary TODO insertion. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-push-task (task-name)
    "Push a task onto the stack."
    (interactive "sTask name: ")
    (select-window (jmw-main-sched-window))
    (org-clock-goto)
    (org-insert-todo-heading-respect-content)
    (org-do-demote)
    (move-end-of-line 1)
    (insert task-name)
    (org-clock-in))
  (define-key 'jmw-org-prefix "p" 'jmw-push-task)
#+END_SRC

=org-clock-goto= from anywhere:
#+BEGIN_SRC emacs-lisp
  (defun jmw-org-clock-goto ()
    (interactive)
    (select-window (jmw-main-sched-window))
    (org-clock-goto))
  (define-key 'jmw-org-prefix "g" 'jmw-org-clock-goto)
#+END_SRC

Marking a task done:
#+BEGIN_SRC emacs-lisp
  (defun jmw-org-done ()
    (interactive)
    (jmw-org-clock-goto)
    (org-todo "DONE")
    (org-clock-goto))
  (define-key 'jmw-org-prefix "d" 'jmw-org-done)
#+END_SRC

Similarly, marking a task cancelled. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-org-cancel ()
    (interactive)
    (jmw-org-clock-goto)
    (org-todo "CANCEL")
    (org-clock-goto))
  (define-key 'jmw-org-prefix "c" 'jmw-org-cancel)
#+END_SRC

Don't show clocking task on mode line. Not particularly elegant. 
#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'org-clock-in-hook
	    (lambda ()
	      (delete 'org-mode-line-string global-mode-string)))
#+END_SRC
*** other
   :PROPERTIES:
   :created:  2020-01-08 20:33:25 CST
   :END:
The window containing =main.org=. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-main-sched-window ()
    (get-buffer-window "main.org" t))
#+END_SRC
** org-babel
   :PROPERTIES:
   :created:  2020-01-08 20:39:50 CST
   :END:
Load it for go. 
#+BEGIN_SRC emacs-lisp
  (use-package ob-go)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (C . t)
     (shell . t)
     (go . t)))
  (org-babel-lob-ingest "~/.emacs.d/library-of-babel.org")
#+END_SRC

Don't prompt for confirmation when executing code blocks. 
#+BEGIN_SRC emacs-lisp 
  (setq org-confirm-babel-evaluate nil)
#+END_SRC
** other
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cl" 'org-store-link) 
  (global-set-key "\C-cc" 'org-capture)
  (setq org-capture-templates
	'(("e"
	   "Computer error"
	   entry
	   (file "~/core/mind/ob/thm/cs/soft/err-log.org")
	   "* %U %?\n %i")
	  ("i"
	   "interesting thought"
	   entry
	   (file+headline "~/core/mind/sys/short/proc/main.org"
			  "interesting thought")
	   "* %U %?\n %i")))
  (setq org-entities-user ; special symbols
	'(("scrB" "\\scrB" t "&#x212C;" "B" "B" "‚Ñ¨") ; "script B"
	  ("scrS" "\\scrS" t "&#x1D4AE;" "S" "S" "ùíÆ") 
	  ("scrF" "\\scrF" t "&#x2131;" "F" "F" "‚Ñ±") 
	  ("RR" "\\RR" t "&#x211D;" "R" "R" "‚Ñù") 
	  ("ZZ" "\\ZZ" t "&#x2124;" "Z" "Z" "‚Ñ§") 
	  ("CC" "\\CC" t "&#x2102;" "C" "C" "‚ÑÇ") 
	  ("PP" "\\PP" t "&#x2119;" "P" "P" "‚Ñô") ; prob
	  ("EE" "\\EE" t "&#x1D53C;" "E" "E" "ùîº") ; e.v.
	  ("eps" "\\eps" t "&#x03B5;" "e" "e" "Œµ") 
	  ("iff" "\\iff" t "&#x21D4;" "<->" "<->" "‚áî") 
	  ("imp" "\\imp" t "&#x21D2;" "->" "->" "‚áí") 
	  ("del" "\\del" t "&#x2202;" "d" "d" "‚àÇ") 
	  ("NN" "\\NN" t "&#x2115;" "N" "N" "‚Ñï") 
	  ))
  (setq org-cycle-include-plain-lists 'integrate)
  (setq org-blank-before-new-entry 
	'((heading . nil)
	  (plain-list-item . nil))) 
  (setq org-startup-truncated nil)
  (setq org-M-RET-may-split-line
	'((headline . nil)
	  (item . nil)))
  (setq org-mark-ring-length 16)
  ;(setq org-popup-calendar-for-date-prompt nil) ;; also turns off live
						;; display
#+END_SRC

Insert creation time as a property when creating a headline. This is
useful for determining when tasks were created. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-org-insert-creation ()
    (org-set-property "created" (format-time-string "%F %T %Z")))
  (add-hook 'org-insert-heading-hook 'jmw-org-insert-creation)
#+END_SRC

I had this, but I don't really use CDLaTeX
#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+END_SRC

Allow more newlines in an emphasis. Following [[https://emacs.stackexchange.com/a/13828/21253][stackexchange]]. 
#+BEGIN_SRC emacs-lisp
  (setf (car (nthcdr 4 org-emphasis-regexp-components)) 50)
  (org-set-emph-re 'org-emphasis-regexp-components
		   org-emphasis-regexp-components)
#+END_SRC

More visible emphasis. According to [[https://www.mail-archive.com/emacs-orgmode@gnu.org/msg115307.html][this]] message, adding different
characters is not going to happen.
#+BEGIN_SRC emacs-lisp
  (setq org-emphasis-alist
	'(("*" (bold :foreground "Yellow")) ;; like highlighting
	  ("/" italic)
	  ("_" underline)
	  ("=" org-verbatim verbatim)
	  ("~" org-code verbatim)
	  ("+" (:strike-through t))))
#+END_SRC

By default, editing org source reorganizes the frame. I want the new
buffer to appear in the original window. 
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'other-window)
#+END_SRC


Don't change window configuration during an =org-capture=. According to
[[https://stackoverflow.com/q/21195327/4019495][SO]], there is no easy way to do this. The key offender is
=delete-other-windows= in the function =org-capture-place-template=. We
adopt the solution given on another [[https://stackoverflow.com/a/54251825/4019495][SO]] post. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-ad-org-capture-place-template (oldfun args)
    (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
      (apply oldfun args)))      
  (advice-add 'org-capture-place-template
	      :around 'jmw-ad-org-capture-place-template)
#+END_SRC

Correct behavior for the agenda. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-ad-org-agenda-place-template (oldfun args)
    (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
      (apply oldfun args)))      
  (advice-add 'org-agenda
	      :around 'jmw-ad-org-capture-place-template)
  (setq org-agenda-window-setup 'other-window)
#+END_SRC

I don't want to log every time an item is repeated:
#+BEGIN_SRC emacs-lisp
  (setq org-log-repeat nil)
#+END_SRC
*** books
Sometimes, I will download books as text files and read them in
org-mode. 

Adds a comment. The implementation may change with aesthetic
preferences. The "a" prefix is for "annotation". 
#+BEGIN_SRC emacs-lisp
  (defun jmw-org-comment ()
    (interactive)
    (insert "*")
    (org-time-stamp-inactive '(16))
    (insert " JMW:* "))
  (define-key 'jmw-org-prefix "ac" 'jmw-org-comment)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun jmw-org-highlight-region (from to)
    (interactive "r")
    (when (use-region-p)
      (save-excursion
	(goto-char to)
	(insert "*")
	(goto-char from)
	(insert "*"))
      (deactivate-mark)
      (fill-paragraph)))
  (define-key 'jmw-org-prefix "ah" 'jmw-org-highlight-region)
#+END_SRC
* pkg
Related to an emacs package. 
** auctex
#+BEGIN_SRC emacs-lisp 
  (use-package tex
    :config
    (setq TeX-view-program-selection
	  (quote
	   (((output-dvi has-no-display-manager)
	     "dvi2tty")
	    ((output-dvi style-pstricks)
	     "dvips and gv")
	    (output-dvi "xdvi")
	    (output-pdf "Okular")
	    (output-html "xdg-open"))))
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq-default TeX-master nil)
    (setq font-latex-fontify-script nil)

    :defer t
#+END_SRC


#+BEGIN_SRC emacs-lisp
    :ensure auctex)
#+END_SRC
** ido
#+BEGIN_SRC emacs-lisp
  (ido-mode 'buffers) ;; only buffers because of bug 36435
  (setq ido-create-new-buffer 'always)
  (setq ido-enable-flex-matching t)
  (defadvice ido-switch-buffer (around no-confirmation activate)
    (let ((confirm-nonexistent-file-or-buffer nil))
      ad-do-it))
#+END_SRC
** elpy
Copied and pasted. 
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :defer t
  :init
  (advice-add 'python-mode :before 'elpy-enable))
#+END_SRC
** buffer-move
#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :bind
    (("<C-S-up>" . 'buf-move-up)
     ("<C-S-down>" . 'buf-move-down)
     ("<C-S-left>" . 'buf-move-left)
     ("<C-S-right>" . 'buf-move-right)))
#+END_SRC
** bash-completion
#+BEGIN_SRC emacs-lisp
  (use-package bash-completion
    :config
    (bash-completion-setup))
#+END_SRC
** emms
#+BEGIN_SRC emacs-lisp
  (use-package emms-setup
    :config
    (emms-all)
    (emms-default-players)
    ;; settings
    (setq emms-source-file-default-directory "~/core/mind/env/ext")
    (setq emms-repeat-playlist t)
    (emms-mode-line 0)
    (emms-playing-time 0)
    (emms-add-directory-tree (concat
			      emms-source-file-default-directory
			      "/chills"))
    (emms-shuffle)

    :ensure emms)
#+END_SRC

Define my emms prefix
#+BEGIN_SRC emacs-lisp
  (fset 'jmw-emms-prefix (make-sparse-keymap))
  (global-set-key (kbd "C-c e") 'jmw-emms-prefix)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (define-key 'jmw-emms-prefix (kbd "<SPC>") 'emms-pause)
#+END_SRC
** ffap
Smart ~C-x C-f~ based on context around point. 
#+BEGIN_SRC emacs-lisp
(ffap-bindings)
#+END_SRC
** cc-mode
Use "line comment style", i.e =//= style comments. 
#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-hook (lambda () (c-toggle-comment-style -1)))
#+END_SRC
** hexl
Emacs's built-in hex editor. 
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-h" 'hexl-find-file)
#+END_SRC
** pyim
A Chinese input method. Installed because ibus pinyin wasn't working
with fullscreen emacs.

#+BEGIN_SRC emacs-lisp
  (use-package pyim
    :config
    (require 'pyim-basedict)
    (pyim-basedict-enable)
    (setq default-input-method "pyim"))
#+END_SRC
** lorem ipsum
   :PROPERTIES:
   :created:  2020-01-29 12:20:45 CST
   :END:
Add lorem ipsum filler text to emacs. 
#+BEGIN_SRC emacs-lisp
  (use-package lorem-ipsum)
#+END_SRC

I don't use the default bindings because it conflicts with org-mode's
~C-c l~.
** vterm
   :PROPERTIES:
   :created:  2020-01-29 19:03:53 CST
   :END:
A terminal emulator within emacs that
- allows curses based applications
- ignores certain shortcuts like ~C-x C-f~. 

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :config
    (setq vterm-min-window-width 50))
#+END_SRC

Define my vterm prefix
#+BEGIN_SRC emacs-lisp
  (fset 'jmw-vterm-prefix (make-sparse-keymap))
  (global-set-key (kbd "C-c v") 'jmw-vterm-prefix)
#+END_SRC

Bind functions
#+BEGIN_SRC emacs-lisp
  (define-key 'jmw-vterm-prefix "b" 'vterm)
  (define-key 'jmw-vterm-prefix "o" 'vterm-other-window)
#+END_SRC

Don't prompt for killing vterm buffers. Code from [[https://stackoverflow.com/a/2708042/4019495][SO]]. 
#+BEGIN_SRC emacs-lisp
  (add-hook 'vterm-mode-hook
	    (lambda ()
	      (set-process-query-on-exit-flag
	       (get-buffer-process (current-buffer)) nil)))	  
#+END_SRC
** go-mode
   :PROPERTIES:
   :created:  2020-02-05 08:31:27 EST
   :END:
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
	  :bind
	  (:map go-mode-map
	  ("M-." . godef-jump)
	  ("C-x 4 ." . godef-jump-other-window)
	  ("C-c C-d" . godoc-at-point))

	  :config
	  ;; (setq godoc-at-point-function 'godoc-gogetdoc)
	  (add-hook 'go-mode-hook
		    (lambda () (setq tab-width 2)))
	  )
#+END_SRC

** dumb-jump
   :PROPERTIES:
   :created:  2020-02-12 13:38:09 EST
   :END:
This is copied from [[https://github.com/jacktasia/dumb-jump][the main page]]. 
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :bind (
	   ;; ("M-g o" . dumb-jump-go-other-window)
	   ("M-g j" . dumb-jump-go)
	   ("M-g b" . dumb-jump-back)
	   ;; ("M-g i" . dumb-jump-go-prompt)
	   ;; ("M-g x" . dumb-jump-go-prefer-external)
	   ;; ("M-g z" . dumb-jump-go-prefer-external-other-window)
	   )
    :config
    ;; (setq dumb-jump-selector 'ivy)
    ;; (setq dumb-jump-selector 'helm)

    )
#+END_SRC

I'm not sure what ~M-g~ is supposed to be. 
#+BEGIN_SRC emacs-lisp :tangle no :results pp
  (global-key-binding (kbd "M-g"))
#+END_SRC

#+RESULTS:
#+begin_example
(keymap
 (98 . dumb-jump-back)
 (106 . dumb-jump-go)
 (9 . move-to-column)
 (112 . previous-error)
 (110 . next-error)
 (27 keymap
     (112 . previous-error)
     (110 . next-error)
     (103 . goto-line))
 (103 . goto-line)
 (99 . goto-char))
#+end_example
** helm
   :PROPERTIES:
   :created:  2020-02-15 14:59:25 EST
   :header-args: :tangle no
   :END:
[2020-02-15 Sat] testing it out. 

[2020-02-16 Sun] IMO, it's alright. Critics are right in that it doesn't
feel that snappy.

[2020-02-16 Sun] I'm using ivy. I'll leave this here, because it is a
usable helm config.

This is all copied from [[http://tuhdo.github.io/helm-intro.html][here]]. Maybe at some point I'll look more deeply. 
#+BEGIN_SRC emacs-lisp
  (require 'helm)
  (require 'helm-config)

  ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
  ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
  ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB work in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  ;; I don't know what any of this means
  (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
	helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
	helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
	helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	helm-ff-file-name-history-use-recentf t
	helm-echo-input-in-header-line t)

  (helm-mode 1)
#+END_SRC

Make helm window occupy bottom fifth of the screen. 
#+BEGIN_SRC emacs-lisp
  (setq helm-autoresize-max-height 0)
  (setq helm-autoresize-min-height 20)
  (helm-autoresize-mode 1)
#+END_SRC

The helm versions of common Emacs commands. 
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
#+END_SRC
** ivy
   :PROPERTIES:
   :created:  2020-02-16 16:41:13 EST
   :END:
Ooh, this is nice. It has a user manual. 

#+BEGIN_SRC emacs-lisp
  (use-package ivy)
#+END_SRC

[2020-02-16 Sun] I'm going to try this. Ivy seems minimalistic and nice.
#+BEGIN_SRC emacs-lisp
  (ivy-mode 1)
#+END_SRC

These are the recommended customizations.
#+BEGIN_SRC emacs-lisp
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) ")
#+END_SRC 


In the manual, sec 4.2, it says
#+BEGIN_QUOTE
Ivy includes several minibuffer bindings, which are defined in the
‚Äòivy-minibuffer-map‚Äô keymap variable.  The most frequently used ones are
described here.
#+END_QUOTE

Test feature: fuzzy file finding. 
#+BEGIN_SRC emacs-lisp :tangle no
  (setq ivy-re-builders-alist
	'((read-file-name-internal . ivy--regex-fuzzy)
	  (t . ivy--regex-plus)))
#+END_SRC
Holy shit, I don't like this. 

Ignore order of input tokens. This is the default of helm. 
#+BEGIN_SRC emacs-lisp
    (setq ivy-re-builders-alist
	  '((t . ivy--regex-ignore-order)))
#+END_SRC

Switch to window containing buffer, if it exists. This is useful on
EXWM. [2020-03-02 Mon] override ~C-x b~. 
#+BEGIN_SRC emacs-lisp
  (defun jmw/ivy-switch-buffer ()
    (interactive)
    (ivy-read "Switch to buffer: " #'internal-complete-buffer
	      :keymap ivy-switch-buffer-map
	      :preselect (buffer-name (other-buffer (current-buffer)))
	      :action 'switch-to-window-or-buffer
	      :matcher #'ivy--switch-buffer-matcher
	      :caller 'ivy-switch-buffer))
  (global-set-key (kbd "C-x b") 'jmw/ivy-switch-buffer)
#+END_SRC
*** counsel
   :PROPERTIES:
   :created:  2020-02-16 21:51:03 EST
   :END:
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind (:map global-map
		("M-x" . counsel-M-x)
		("C-x C-f" . counsel-find-file)
		("M-y" . counsel-yank-pop)
		("C-h v" . counsel-describe-variable)
		("C-h f" . counsel-describe-function)
	   :map org-mode-map
	   ("C-c C-j" . counsel-org-goto))

    :config
    (setq ivy-initial-inputs-alist '(())))
#+END_SRC

Push onto the org mark ring when using counsel to goto. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-ad-counsel-org-goto ()
    (org-mark-ring-push))
  (advice-add 'counsel-org-goto
	      :before 'jmw-ad-counsel-org-goto)
#+END_SRC
*** ivy-rich
   :PROPERTIES:
   :created:  2020-02-18 15:31:59 EST
   :END:
Display more info in ivy. For example, make ~M-x~ display a column of
documentation alongside the list of candidate functions. 
#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :config
    ;; (ivy-rich-mode 1)
    )
#+END_SRC

The reason I looked into this was for =counsel-find-file=. I wanted to
see =ls -l= like stuff. 

The first step is to define a function for the file size. 
#+BEGIN_SRC emacs-lisp
  (defun ivy-rich-file-size (candidate)
    (let ((fname (expand-file-name candidate ivy--directory)))
      (if (or (not (file-exists-p fname)) (file-remote-p fname))
	  ""
	(file-size-human-readable (file-attribute-size
				   (file-attributes fname))
				  "si"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (plist-put ivy-rich-display-transformers-list
	     'counsel-find-file
	     '(:columns
	      ((ivy-rich-candidate
		(:width 40))
	       ;; (ivy-rich-file-user
	       ;;  (:width 4 :face font-lock-doc-face))
	       ;; (ivy-rich-file-group
	       ;;  (:width 4 :face font-lock-doc-face))
	       ;; (ivy-rich-file-modes
		;; (:width 11 :face font-lock-doc-face))
	       (ivy-rich-file-size
		(:width 6 :face font-lock-doc-face))
	       (ivy-rich-counsel-find-file-truename
		(:face font-lock-doc-face))
	       ;; (ivy-rich-file-last-modified-time
	       ;;  (:width 30 :face font-lock-doc-face))
	       )))
  (ivy-rich-set-display-transformer)
#+END_SRC
** md4rd
   :PROPERTIES:
   :created:  2020-02-22 13:20:51 EST
   :END:
#+BEGIN_SRC emacs-lisp
  (use-package md4rd :ensure t
    :bind (:map md4rd-mode-map
		("u" . tree-mode-goto-parent)
		("\t" . tree-mode-toggle-expand)
		("f" . tree-mode-next-sib)
		("b" . tree-mode-previous-sib)
		)
    :config
    (add-hook 'md4rd-mode-hook 'md4rd-indent-all-the-lines)
    (setq md4rd-subs-active '(emacs))
    (setq md4rd--oauth-access-token
	  "34674419-_-P8Ht8Ht-2uvHv-hBFHBTvAZxE")
    (setq md4rd--oauth-refresh-token
	  "34674419-RHL3BClht1JhmFYOQ7jXwjBqLt0")
    (run-with-timer 0 3540 'md4rd-refresh-login))
#+END_SRC
** exwm
   :PROPERTIES:
   :created:  2020-03-01 19:11:44 EST
   :END:
[2020-03-01 Sun] Trying this out. We definitely don't want to install
this on every new machine. 
*** main
    :PROPERTIES:
    :created:  2020-03-10 00:34:57 EDT
    :END:
[2020-03-02 Mon] I'm not sure the system tray is doing anything right
now.
#+BEGIN_SRC emacs-lisp
  ;; (ignore-errors
    (use-package exwm
      :ensure nil 
      :demand t

      :config
      (require 'exwm-config)
      (exwm-config-default)
      (require 'exwm-systemtray)
      (exwm-systemtray-enable)
      (setq exwm-systemtray-height 16)
      (setq exwm-input-global-keys
	    `(
	      ;; Bind "s-r" to exit char-mode and fullscreen mode.
	      ([?\s-r] . exwm-reset)
	      ;; Bind "s-w" to switch workspace interactively.
	      ([?\s-w] . exwm-workspace-switch)
	      ;; Bind "s-0" to "s-9" to switch to a workspace by its index.
	      ,@(mapcar (lambda (i)
			  `(,(kbd (format "s-%d" i)) .
			    (lambda ()
			      (interactive)
			      (exwm-workspace-switch-create ,i))))
			(number-sequence 0 9))
	      ;; Bind "s-&" to launch applications ('M-&' also works if
	      ;; the output buffer does not bother you).
	      ([?\s-&] . (lambda (command)
			   (interactive (list (read-shell-command "$ ")))
			   (start-process-shell-command command nil command)))
	      ;; Bind "s-<f2>" to "slock", a simple X display locker.
	      ;; ([s-f2] . (lambda ()
	      ;; 	      (interactive)
	      ;; 	      (start-process "" nil "/usr/bin/slock")))
	      (,(kbd "C-;") . other-window)
	      (,(kbd "C-'") . other-frame)
	      ;; (,(kbd "<print>") . desktop-environment-screenshot)
	      ))
      (setq exwm-input-simulation-keys
	'(
	  ;; movement
	  ;; ([?\C-b] . [left])
	  ;; ([?\M-b] . [C-left])
	  ;; ([?\C-f] . [right])
	  ;; ([?\M-f] . [C-right])
	  ;; ([?\C-p] . [up])
	  ;; ([?\C-n] . [down])
	  ;; ([?\C-a] . [home])
	  ;; ([?\C-e] . [end])
	  ;; ([?\M-v] . [prior])
	  ;; ([?\C-v] . [next])
	  ;; ([?\C-d] . [delete])
	  ;; ([?\C-k] . [S-end delete])
	  ;; cut/paste.
	  ;; ([?\C-w] . [?\C-x])
	  ([?\M-w] . [?\C-c])
	  ([?\C-y] . [?\C-v])
	  ;; search
	  ;; ([?\C-s] . [?\C-f])))
	  ))
      (setq exwm-workspace-show-all-buffers t)
      (setq exwm-layout-show-all-buffers t)
      )  
    ;; )
#+END_SRC
*** desktop-environment
    :PROPERTIES:
    :created:  2020-03-10 00:22:02 EDT
    :END:
#+BEGIN_SRC emacs-lisp
  (use-package desktop-environment
    :ensure nil

    :config
    (setq desktop-environment-update-exwm-global-keys :global)
    (desktop-environment-mode)
    )
#+END_SRC

Redefine screenshots:
#+BEGIN_SRC emacs-lisp
  (defun desktop-environment-screenshot ()
    (interactive)
    (shell-command "scrot -s '/tmp/%F_%T_$wx$h.png' -e 'xclip -selection clipboard -target image/png -i $f &>/dev/null'"))
#+END_SRC
** minions
   :PROPERTIES:
   :created:  2020-03-15 21:47:44 EDT
   :END:
** smart-mode-line
   :PROPERTIES:
   :created:  2020-03-16 17:17:54 EDT
   :END:
A more customizable mode line. 

Mark theme as safe. 
#+BEGIN_SRC emacs-lisp
  (setq custom-safe-themes
	(quote
	 ("a27c00821ccfd5a78b01e4f35dc056706dd9ede09a8b90c6955ae6a390eb1c1e" default)))
#+END_SRC

Main loading. 
#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :config
    (sml/setup))
#+END_SRC
** symon
   :PROPERTIES:
   :created:  2020-03-16 18:53:51 EDT
   :END:
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package symon
    :straight (:host github :repo "ieure/symon")
    :config (symon-mode 1))
#+END_SRC
* mode
Related to a mode, minor or major. 
** comint-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'comint-mode-hook ;; don't want line wrapping in REPLs
      (lambda () (setq auto-fill-function '())))
#+END_SRC
** text-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook
	  (lambda () (setq fill-column 72)))
#+END_SRC
** custom
   :PROPERTIES:
   :created:  2020-01-29 18:33:43 CST
   :END:
I don't like having Custom litter my =init.el= with stuff. This sets it
to save in a different file, which I don't load. 
#+BEGIN_SRC emacs-lisp 
  (setq custom-file (concat user-emacs-directory "/custom.el"))
#+END_SRC
** other
#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (column-number-mode 1)
    (size-indication-mode 1)
    (menu-bar-mode 0) ;; from https://youtu.be/PKaJoqQQoIA?t=423
    (tool-bar-mode 0) ;; from https://youtu.be/PKaJoqQQoIA?t=423
    (scroll-bar-mode 0)
    (winner-mode 1)
    (fringe-mode 1))
#+END_SRC
* startup
Look and feel of emacs upon completion of startup. 
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . fullboth))
  (set-default-font "Ubuntu Mono-12")
  (setq inhibit-startup-screen t)

#+END_SRC

Setup initial applications in EXWM. 
#+BEGIN_SRC emacs-lisp
  (defun jmw/exwm-init-apps ()
    (exwm-workspace-switch 1)
    (start-process-shell-command (getenv "BROWSER"))

    (exwm-workspace-switch 2)
    (start-process-shell-command (getenv "PDF_VIEWER"))

    (exwm-workspace-switch 3)
    (start-process-shell-command "anki"))
#+END_SRC

The main thing. 
#+BEGIN_SRC emacs-lisp
  (add-hook 'window-setup-hook
	    (lambda ()
	      (split-window-right) 
	      (split-window-right)
	      (balance-windows)
	      (find-file (concat (getenv "PROC_DIR")
				 "/main.org"))
	      (set-window-dedicated-p (get-buffer-window "main.org")
				      t) 
	      (windmove-right)
	      (vterm)
	      (windmove-right)
	      (vterm)
	      (when (member 'exwm features)
		(jmw/exwm-init-apps))
	      (select-window (jmw-main-sched-window))
	      ))
#+END_SRC
** theme
   :PROPERTIES:
   :created:  2020-01-28 22:45:41 CST
   :END:
[2020-01-28 Tue] I haven't given this much thought. =manoj-dark= is
permissible.
#+BEGIN_SRC emacs-lisp
  (load-theme 'manoj-dark)
#+END_SRC
* other
  :LOGBOOK:
  CLOCK: [2020-01-09 Thu 16:30]--[2020-01-09 Thu 16:31] =>  0:01
  :END:
Default case. As of [2019-12-24 Tue], not too organized. 

Define =jmw-prefix=. This is the prefix key for my personal stuff. 
#+BEGIN_SRC emacs-lisp
  (fset 'jmw-prefix (make-sparse-keymap))
  (global-set-key (kbd "C-c j") 'jmw-prefix)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
  (setq-default fill-column 72)
  (setq scroll-preserve-screen-position t)
  (setq tab-stop-list '(4 8))
  (setq ansi-color-names-vector
	["black" "red3" "green3" "yellow3"
	 "dodger blue" "magenta3" "cyan3" "gray90"])
  (setq ansi-color-map (ansi-color-make-color-map))

  ;;;; other ;;;;
  (server-start) 
#+END_SRC

These aren't bound to anything by default. Put them to good use. 
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-;") 'other-window)
  (define-key org-mode-map (kbd "C-'") nil)
  (global-set-key (kbd "C-'") 'other-frame)
#+END_SRC

Type ~y~ or ~n~ instead of yes/no. I've copied this from [[https://pages.sachachua.com/.emacs.d/Sacha.html#org2509ed6][Sacha Chua]]. One
would think there was a better way of doing this. 
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

If exists a window containing buffer, switch to it. Otherwise, switch to
buffer.
#+BEGIN_SRC emacs-lisp
  (defun switch-to-window-or-buffer (buffer)
    (let ((containing-window (get-buffer-window buffer t)))
      (if containing-window
	  (select-window containing-window)
	(switch-to-buffer buffer))))
#+END_SRC
** 7z
I use 7z as my default encryption format. This opens 7z files in the
style I want: the file will be extracted to my temporary directory when
first called, and then rearchived when called again. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-7z (zfile file outfile)
    (if (file-exists-p outfile)
	(progn
	  (message "Preparing to compress")
	  (sit-for 0.25)
	  (call-process-shell-command
	   (concat "7z a -p"
		   (read-passwd "Password? " t)
		   " "
		   zfile
		   " "
		   outfile))
	  (call-process-shell-command
	   (concat 
	    "shred -u "
	    outfile)))
      (progn
	(message "Preparing to extract")
	(sit-for 0.25)
	(unless (file-exists-p zfile)
	  (error (concat
		  "Archive file "
		  zfile
		  " does not exist.")))
	(while (not (eq
		     (call-process-shell-command
		      (concat "7z e -p"
			      (read-passwd "Password? ")
			      " -o"
			      (getenv "TEMP") ;; this could be an
					      ;; issue. Really, we want
					      ;; the dir name
			      " "
			      zfile
			      " "
			      file))
		     0))
	  (message "Incorrect Password. Try again.")
	  (sit-for 0.5))
	(find-file outfile))))

#+END_SRC

The wander archive is a kind of diary. I write in it about once a
month. It's encrypted because it contains sensitive info.
#+BEGIN_SRC emacs-lisp
  (defun jmw-wander ()
    (interactive)
    (jmw-7z (getenv "WANDER_ARCHIVE")
	    "wander.txt"
	    (concat (getenv "TEMP")
		    "/wander.txt")))
  (define-key 'jmw-prefix "w" 'jmw-wander)
#+END_SRC

This contains passwords. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-safe ()
    (interactive)
    (jmw-7z (getenv "SAFE_ARCHIVE")
	    "safe.org"
	    (concat (getenv "TEMP")
		    "/safe.org")))
  (define-key 'jmw-prefix "s" 'jmw-safe)
#+END_SRC
** timer
   :PROPERTIES:
   :created:  2020-02-01 20:12:03 CST
   :END:
I use timers in my workflow. They're primarily used as end conditions of
runs.

Define the timer prefix, and bind it. 
#+BEGIN_SRC emacs-lisp
  (fset 'jmw-timer-prefix (make-sparse-keymap))
  (global-set-key (kbd "C-c t") 'jmw-timer-prefix)
#+END_SRC

This is how you create a timer. In the future, this should be extended
to take in info about the current run. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-run-with-timer (durationspec)
    (interactive "sDuration: ")
    (setq jmw-timer
	  (run-with-timer (timer-duration durationspec)
			  0.5
			  'jmw-times-up)))
  (define-key 'jmw-timer-prefix "s" 'jmw-run-with-timer)
#+END_SRC

This is what happens when time is up. 
#+BEGIN_SRC emacs-lisp
  (defun jmw-times-up ()
    "Single function run when timer expires"
    (play-sound-file "~/core/prod/bin/other/alarm.wav"))
#+END_SRC

The rest of these functions need serious work.
#+BEGIN_SRC emacs-lisp
  (defun jmw-find-timer (timerlist)
    (if timerlist
	(if (equal (timer--function (car timerlist))
		   'jmw-times-up)
	    (car timerlist)
	  (jmw-find-timer (cdr timerlist)))
      nil))
  (defun jmw-cancel-timer ()
    (interactive)
    (cancel-timer jmw-timer)
    (let ((timer (jmw-find-timer timer-list)))
      (if timer
	  (setq jmw-timer timer))))
  (defun jmw-time-left ()
    "Timer info. May be expanded to more than just time remaining."
    (interactive)
    (let* ((time-diff (time-subtract (timer--time jmw-timer)
				     (current-time)))
	   (floats (float-time time-diff))
	   (seconds (floor floats)))
      (message "%ss" seconds)))
  (define-key 'jmw-timer-prefix "c" 'jmw-cancel-timer)
  (define-key 'jmw-timer-prefix "d" 'jmw-time-left) ;; "display"
#+END_SRC
* misc
  :PROPERTIES:
  :created:  2020-03-15 22:38:41 EDT
  :header-args: :tangle no :results pp
  :END:
#+BEGIN_SRC emacs-lisp 
mode-line-format
#+END_SRC

#+RESULTS:
: ("%e" mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position
:  (vc-mode vc-mode)
:  "  " minions-mode-line-modes mode-line-misc-info mode-line-end-spaces)

#+BEGIN_SRC emacs-lisp
vc-mode
#+END_SRC

#+RESULTS:
#+begin_example
#(" Git:master" 1 5
  (mouse-face mode-line-highlight local-map
	      (keymap
	       (mode-line keymap
			  (down-mouse-1 menu-item "Version Control" vc-menu-map :filter vc-menu-map-filter)))
	      face vc-edited-state help-echo "Locally modified file under the Git version control system\nCurrent revision: 8e5ed903a404e6d58a5350d35ce0eeaa8524ed6b\nmouse-1: Version Control menu")
  5 11
  (mouse-face mode-line-highlight local-map
	      (keymap
	       (mode-line keymap
			  (down-mouse-1 menu-item "Version Control" vc-menu-map :filter vc-menu-map-filter)))
	      help-echo "Locally modified file under the Git version control system\nCurrent revision: 8e5ed903a404e6d58a5350d35ce0eeaa8524ed6b\nmouse-1: Version Control menu" face vc-edited-state))
#+end_example
